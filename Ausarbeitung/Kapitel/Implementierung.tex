\chapter{Implementierung} \label{chap:Implementierung}
\graphicspath{{Abbildungen/Implementierung/}}
Für eine Umsetzung eines solchen Konzepts, wie es in dem Kapitel \ref{chap:Konzept}erwähnt worden ist, wird es nötig eine Implementierung des Spiels Snake, der beiden Algorithmus-Arten, Ablaufroutine sowie der Statistik-Erzeugung durchzuführen. Als Programmiersprache wurde Python (3.7) gewählt.\\
Python bietet im Bereich des Maschine Learning eine Vielzahl an Frameworks, welche nicht nur bei der Implementierung des Envs. helfen, sondern auch welche, die Funktionalität der Neuronalen Netzwerke bereitstellen.\\
Das in dieser Implementierung wurde sich für das Maschine Learning Framework PyTorch (\url{https://pytorch.org/}) entschieden. Dieses erlaubt auf einfacher Weise das Konzipieren der in \ref{sec:Konzept_Netzstruktur} vorgestellten NNs.

\section{Package Struktur}
Für eine bessere Abtrennung der einzelnen Komponenten wurde sich für die folgende Projektstruktur entschieden. 
\\Alle Ordner werden in src aufbewahrt. Dieser besitzt die drei Unterordner resources, snakeAI und statistic.\\
In dem Ordner resources werden alle erzeugten Daten der Trainingsläufe und Testläufe sowie einige weitere images führ die Projektpräsentation aufbewahrt.\\
Der Ordner statistic beinhaltet die Files, in welche die Klasse zur Auswertung der Trainings- und Testdaten, aus welchen Statistiken generiert werden, aufbewahrt wird.\\
Der SnakeAI Ordner beinhalte dient als Sammelordner zur Lagerung der gym\_games, zu welches auch das, im Rahmen dieser Ausarbeitung, implementierte Spiel Snake gehört. Auch die Agenten sind in dem Ordner agent, in Unterordnern, aufbewahrt. Jeder Algorithmus erhält dabei seinen eigenen Unterordner.
\begin{figure}[H]
	\centering
	\def\svgscale{0.1}
	\input{Abbildungen/Implementierung/Package_Struktur.pdf_tex}
	\caption[Package Struktur]{Darstellung der Package Struktur.}
	\label{fig:Package_Struktur}
\end{figure}


\section{Snake Environment}
Zur Implementierung des Spiels Snake wurde das Framework gym von OpenAI genutzt (\url{https://gym.openai.com/}). Dieses bietet viele Methoden und Vorgaben in der Projektstruktur, welche das Implementieren erleichtern. So besteht das Snake Environment, welches im snake\_env Package liegt (siehe \ref{fig:Package_Struktur}), aus den wesentlichen Files:
\begin{itemize}
	\item gui
	\item observation
	\item reward
	\item snake\_env
	\item snake\_game
\end{itemize}

\subsection{Spiellogik}
Die Spiellogik ist ist hauptsächlich im snake\_game File implementiert. Anders als im Konzept, existiert keine Spiellogik-Klasse. Viel mehr wird die gesamte Verwaltung von der SnakeGame Klasse übernommen, welche der Game-Komponente gleichkommt. Die Gesamtheit aller Komponenten spannt dabei die Spiellogik auf. Diese Abweichung des Konzepts hat sich angeboten, da so die Implementierung einer weiteren Klasse verhindert werden konnte. Dies minimiert den Implementierungsaufwand.\\
\\Die Game-Komponente, welche der SnakeGame Klasse entspricht, befindet sich im snake\_game File.
\begin{lstlisting}[label=alg:SnakeGame_Konstruktor]
\end{lstlisting}
\begin{python} 
	def __init__(self, shape, has_gui):
		self.ground = np.zeros((shape[0], shape[1]), dtype=np.int8)
		pos = np.array((randint(0, shape[0] - 1), randint(0, shape[1] - 1)))
		self.p = Player(pos=pos, tail=[(pos[0], pos[1])], direction=randint(0, 3), id=1, c_s=1, c_h=2,
		inter_apple_steps=0, done=False)
		self.reward = Reward(self)
		self.shape = shape
		self.has_gui = has_gui
		self.step_counter = 0
		self.ground[pos[0], pos[1]] = self.p.c_h
		self.apple = self.make_apple()
		if has_gui:
		self.gui = GUI(self.shape)
\end{python}

Zur Erstellung der SnakeGame-Klasse werden die Spielfeldmaße (shape) und has\_gui übertragen und in der Klasse gespeichert. Letzteres ist ein Boolean, welche die GUI ein oder ausschaltet. Als nächstes wird die Spieloberfläche (ground) generiert, welche durch ein Numpy Array (\url{https://numpy.org/}) implementiert wird. Die Position des Spieles (pos) wird daraufhin als nächstes zufallsbasiert bestimmt. Mit dieser Information kann die Datenhaltungsklasse des Players erzeugt werden (siehe \ref{sec:Implementierung_Player}). Der step\_counter dient zur Bestimmung der gegangenen Schritte der Snake. Zum Schluss wird das Spielfeld mit der Position der Snake aktualisiert, ein Apfel wird mit der make\_apple() Methode generiert, welche sogleich das Spielfeld anpasst und je nach dem has\_gui Boolean wird ein GUI-Objekt (siehe \ref{sec:Implementierung_GUI}) instanziiert.\\
\\Die SnakeGame-Klasse implementiert nach dem Konzept (siehe \ref{sec:Konzept_Spiellogik}) die folgenden Methoden: action, observe, evaluate, reset, view und make\_apple.

\subsubsection{Action}
Die action Methode implementiert die Spiellogik und damit die Aktionsabarbeitung. Aus diesem Grund wird ihr die, vom Agenten bestimmte, Aktion in Form eines Integers übergeben. Daraufhin wird überprüft, ob die Snake bereits die maximale Schrittanzahl überschnitten hat. Danach werden step\_counter und p.inter\_apple\_steps inkrementiert und die Aktion wird umgesetzt. Um dies umzusetzen wird die direction im Player Objekt angepasst, entsprechend der Beschreibung im Konzept (siehe \ref{sec:Konzept_Spielablauf}). Die directions und die actions sind dabei mit den Zahlen von eins bis vier bzw. von ein bis drei codiert.
\begin{python}
	def action(self, action):
		if self.p.inter_apple_steps >= self.max_snake_length:
			self.p.done = True
			return
		self.p.inter_apple_steps += 1
		self.step_counter += 1
		if action == 0:
			self.p.direction = (self.p.direction + 1) % 4
		elif action == 1:
			self.p.direction = (self.p.direction - 1) % 4
		else:
			pass
\end{python}
Nach der Manipulation der Snake direction wird ein Schritt gegangen. Dazu wird die p.pos entsprechende der neuen direction angepasst. Da zwar p.pos angepasst ist jedoch noch nicht die Liste p.tail, welche alle Snake-Glieder beinhaltet und das Spielfeld (ground) kann nun überprüft werden, ob die Aktion zum sofortigen Tod führt. Dabei werden noch nicht alle Todesmöglichkeiten berücksichtigt. Einzig die Tode, welche durch das Verlassen des Spielfeldes auftreten, da diese zu Exception führen würden.\\ 
Ein Beispiel dafür wäre, der Versuch das Spielfeld (ground) zu aktualisieren mit einer Position die außerhalb lägt.\\
Sollte dieser Fall eintreten, so wird p.done auf True gesetzt, was deinen terminalen Zustand ankündigt und die Methode würde beendet. Sollte diese Aktion nicht zum Tod führen, so wird der neue Snake-Kopf in die p.tail an vorderster Stelle eingefügt.
\begin{python}
	self.p.pos[self.p.direction % 2] += -1 if self.p.direction % 3 == 0 else 1
	if not all(0 <= self.p.pos[i] < self.ground.shape[i] for i in range(2)):
		self.p.done = True
		return
	self.p.tail.insert(0, (self.p.pos[0], self.p.pos[1]))
\end{python}
Danach wird überprüft ob die Snake alle möglichen Äpfel gegessen hat, ob sie daher gewonnen hat. Sollte dies der Fall sein, so wird wieder p.done auf True gesetzt und die Methode terminiert.
\begin{python}
	 if len(self.p.tail) == self.max_snake_length:
		self.p.done = True
		return
\end{python}
Hat die Snake nicht gewonnen haben, so wird eine Fallunterscheidung zwischen zwei Situationen durchgeführt. Der erste Fall tritt ein sofern die Snake einen Apfel gefressen hat, dann sind die Positionen des neuen Snake-Kopfes und des Apfels gleich. Daher wird die Matrix mit dem neuen Snake-Kopf aktualisiert und ein neuer Apfel wird mit der Methode make\_apple generiert. Dieser wird gleich in das Spielfeld (ground) eingepflegt. Zum Schluss wird noch der p.inter\_apple\_steps, welcher die Schritte seit dem letzten Fressen aufaddiert auf null gesetzt, da ein Apfel gefressen wurde und reward.has\_grown wird auf True gesetzt, da die Snake gewachsen ist. reward.has\_grown dient dabei nur zur Bestimmung des Reward und st daher in der Reward-Klasse definiert.
\begin{python}
	if self.p.tail[0] == self.apple:
		self.ground[self.p.tail[0][0], self.p.tail[0][1]] = self.p.c_h
		self.apple = self.make_apple()
		self.p.inter_apple_steps = 0
		self.reward.has_grown = True
\end{python}
Ist die Snake jedoch nicht gewachsen, so triff der zweite Fall ein. Um die Illusion von Bewegung zu erzeugen, muss das letzte Schwanzstück der Snake entfernt werden, da ansonsten die Snake um ein Glied gewachsen wäre. Dieses wird sowohl vom Spielfeld als auch aus p.tail entfernt. Danach wird noch reward.has\_grown auf False gesetzt, da die Snake nicht gewachsen ist.
\begin{python}
	else:
		self.ground[self.p.tail[-1][0], self.p.tail[-1][1]] = 0
		del self.p.tail[-1]
		self.reward.has_grown = False
\end{python}
Nach dieser Fallunterscheidung muss überprüft werden, ob die Snake nicht in sich selber gelaufen ist.
\begin{python}
	if len(self.p.tail) != len(set(self.p.tail)):
		self.p.done = True
		return
\end{python}
Zum Schluss der action Methode wir, sofern die Snake bis zu diesem Punkte nicht gewonnen oder verloren hat, über die p.tail List, welche alle die Positionen alles Schwanzglieder gespeichert hat, iteriert. Dabei wird das Spielfeld mit allen Gliedern erneut aktualisiert. Dabei wird jedem normalen Schwanzglied die Zahl eins in der Matrix zugeordnet. Ausnahmen stellen der Kopf und das letzte Schwanzstück der Snake dar. Diese werden in der Matrix mit zwei bzw. -1 dargestellt. Die Werte für die Schwanzglieder sind in der Player-Klasse definiert (siehe \ref{sec:Implementierung_Player}).
\begin{python}
	if not self.p.done:
		for s in self.p.tail:
			self.ground[s[0], s[1]] = self.p.c_s
		self.ground[self.p.tail[-1][0], self.p.tail[-1][1]] = -1
		self.ground[self.p.tail[0][0], self.p.tail[0][1]] = self.p.c_h
\end{python}

\subsubsection{Observe}
Die Observe Methode ruft die make\_obs Funktion im observation File auf. Zu diesem Zweck werden der Funktion die für die Obs benötigten Inforamtionen als Argumente übergeben. Näheres zur Obs in \ref{sec:Implementierung_Observation}.
\begin{python}
    def observe(self):
			return make_obs(self.p.id, self.p.pos, self.p.tail_pos, self.p.direction, self.ground, self.apple, self.p.inter_apple_steps)
\end{python}

\subsubsection{Evaluate}
Der evaluate Methode wird ein String übergeben, welche zur Auswahl der Reward-Funktion dient. Dies ist nötig, da im Rahmen der Optimierung B eine neue Reward-Funktion definiert wurde. Ansonsten ruft evaluate die entsprechende Reward-Funkion auf, welche in der Reward-Klasse definiert wurde (siehe \ref{label}).
\begin{python}
	def evaluate(self, reward_function="standard"):
		if reward_function == "standard":
			return self.reward.standard_reward
		elif reward_function == "optimized":
			return self.reward.optimized_reward
		else:
			raise ValueError("Wrong reward function.")
\end{python}

\subsubsection{Reset}
In der Reset Methode wird der bisherige Spielfortschritt zurückgesetzt. Dafür wird das Spielfeld mit Nullen überschrieben und die Player eigene reset Methode wird aufgerufen, welchedas Player-Objekt in seinen Ursprungszustand zurückversetzt. Danach verläuft die Methode analog zur Erstellung des SnakeGame-Objektes (siehe \ref{alg:SnakeGame_Konstruktor})
\begin{python}
	def reset_snake_game(self):
		self.ground.fill(0)
		pos = np.array((randint(0, self.shape[0] - 1), randint(0, self.shape[1] - 1)))
		self.p.player_reset(pos)
		self.step_counter = 0
		self.reward.has_grown = False
		self.ground[pos[0], pos[1]] = self.p.c_h
		self.apple = self.make_apple()
		if self.has_gui:
			self.gui.reset_GUI()
\end{python}

\subsection{Player} \label{sec:Implementierung_Player}

\subsection{Observation} \label{sec:Implementierung_Observation}

\subsection{Reward} \label{sec:Implementierung_Reward}

\subsection{GUI} \label{sec:Implementierung_GUI}